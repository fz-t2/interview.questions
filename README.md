# interview.questions

*30 минут на техническое интервью.*

*Предлагаются группы вопросов по языкам и технологиям: **HTML** (1-2) и **CSS** (1-2), **JavaScript** (4-5) и **TypeScript** (0-1), **React** (3).*

*Все группы разделены на две части: "простые" и "интересные". "Простые" предназачены, чтобы разговорить кандидата: предполагается, что на них сможет ответить любой человек, хотя бы приблизительно знакомый с web. "Интересные" нужны, чтобы проверить понимание темы кандидатом, и они могут озадачить того, кто не знает правильного ответа. Многие "Простые" вопросы включают в себя дополнительные, которые выполняют функцию "Интересных", и они должны расцениваться соответственно.*

## HTML и CSS
5-10 минут

### Простые

+ **Что такое "семантическая верстка"?**
  Структура документа не случайна и отражает логику его содержимого, а не, например, ожидания от его внешнего вида. Отдельные блоки контента помещаются в специальные "семантические" теги, которые способны описывать эти блоки наиболее точно с точки зрения контента.
+ + **Какие семантические теги вы могли бы назвать?**
  В HTML5 почти все теги, кроме *div* и *span*, могут считаться семантическими, и в HTML5 более 100 стандартных тегов. Примеры: main, h3, article, aside, p, nav, table, section. Несемантические теги отличаются от семантических тем, что они ничего не говорят о своем содержимом. Некоторые несемантические теги ранних спецификаций (*b* или bold, *i* или italic) были реклассифицированы в HTML5 в семантические (*b* стал bring attention to element, i стал idiomatic text).
+ **В чем разница между блочными и строчными элементами (block & inline elements)? Какое CSS свойство позволяет этим управлять?**
  Блочные помещаются на новую строку, имеют высоту, определяюмую содержимым, и стараются занять все доступное для них горизонтальное пространство. В Normal Document Flow (стандартное поведение страницы) они следуют один за другим. Строчные элементы никогда не помещаются на новую строку и занимают то пространство, которое было отведено для них внешними тегами (как правило, минимальное). В Normal Flow они следуют в соответствии с режимом письма (у европейцев слева направо, у арабов справа налево, у японцев и китайцев сверху вниз и т.д.). CSS свойство, которое позволяет изменять тип отображения для HTML элементов, называется display.
+ + **Какие еще значения может принимать display и сколько их может быть одновременно? Какие значения считаются дефолтными?**
  Не считая глобальных значений, display понимает одиннадцать (11) ключевых слов, восемь из которых имеют альтернативный синтаксис, и значительное число утилитарных (как table-item) или специфичных для локализации (как ruby). Помимо block и inline, display может принимать также, в том числе, flex, grid, table и none значения. У каждого элемента HTML есть всегда свое дефолтное значение display, которое почти всегда является inline, block, inline-block, list-item или table-item.
+ **В чем разница между *id* и *class* атрибутами HTML тэга?**
  Спецификация говорит, что можно использовать только один идентификатор для элемента, и этот идентификатор должен быть уникальным для страницы. Один и тот же элемент может иметь несколько классов (атрибут class принимает значение строки, состоящей из нескольких разделенных пробелами слов), а также страница может иметь любое число элементов с одинаковыми классами. Помимо этого, у идентификаторов есть дополнительные особенности: hash value (значение после хеша), которое можно добавить в адресную строку, чтобы браузер сам прокрутил страницу и смог отобразить содержимое (www.wikipedia.com/dogs#hound, чтобы браузер попытался найти и показать уникальный элемент с id='hound'); также, JavaScript быстрее ищет нужный элемент по идентификатору.
+ + **Что будет, если на одной странице будет несколько разных элементов с одинаковым идентификатором? Все сломается?**
  Хотя использование разных элементов с одинаковыми id запрещено спецификацией, браузеры прощают эти ошибки и даже не оповещают о них: статичная страница отрендерится "нормально" (в кавычках потому, что эта "нормальность" уже не регулируется никаким правилом интерпретации HTML, и то, как именно будет отображена страница, может теоретически отличаться от браузера к браузеру). Тем не менее, ошибки такого рода могут проявить себя на уровне JavaScript, если будем пытаться найти эти элементы.  
+ + **Можно ли обойтись без классов и идентификаторов, но при этом сохранить как презентацию, так и функциональность произвольно сложной страницы (используя только стандартные языки web)? Если да, то как?**
  Как и XML, HTML5 не запрещает использование кастомных тегов, и элемент <div class="squared" /> можно заменить на элемент <squared></squared> и, так, отказаться от применения классов вообще. Это не запрещено спецификацией HTML5 и никак не связано с WebComponents. CSS также поддерживает области видимости посредством @layer и @scope правил. ShadowDOM, хотя и не предназначен для этих целей, позволяет инкапсулировать функционал и внешний вид отдельных элементов внутри себя.
+ **В чем различия между HTML и JSX?**
  HyperText Markup Language -- стандартный язык разметки документа в web. JavaScript+XML -- расширение для JavaScript, которое дает возможность писать HTML код внутри JavaScript. Отличия состоят в следующем. Браузеры не понимают JSX, а значит его нужно компилировать (например, с помощью Babel). Любой участок JSX кода -- это синтаксический сахар над createElement()/createElementFragment(), поэтому он всегда должен быть обернут в единственный внешний элемент (HTML это безразлично). У JSX есть props, а у HTML -- атрибуты, и они могут быть разными из-за зарезервированных в JavaScript слов (className в JSX вместе class в HTML). Все тэги JSX могут быть самозакрывающимися, в отличие от некоторых тэгов HTML. JSX (точнее, React) часто требует записи в сamelCase нотации, HTML -- не требует никогда. (Список не полный.)
+ + **Как Babel транспайлит JSX в HTML?**
Плагин @babel/preset-react содержит правила для преобразования JSX. Он преобразует JSX-элементы (div, p, ...) в вызовы функции React.createElement(). 
+ **Что такое meta элементы и для чего они применяются?**
  Meta элементы содержат в себе описывающие документ мета-данные, которые используются кравлерами, браузерами, устройствами чтения и не только для получения специфичной для них информации. 

### Интересные

+ **Что такое void элементы в HTML? Можете ли привести какой-нибудь в пример?**
  Void-элементы -- элементы, которые не содержат и не могут содержать в себе других элементов. Все элементы, создаваемые самозакрывающимися тэгами, являются void-элементами: img, br, link, input и другие. 
+ **Что такое стекинг-контекст (stacking context) в CSS? Как можно его создать или повлиять на него? Какие у него есть ограничения?**
  Реализация и интерпретациия третьего измерения при рендеринге страницы: правила отображения элементов поверх других элементов. Новый стенкинг контекст создается каждый раз для каждого элемента, когда он получает для свойства position значения fixed и sticky, а также absolute или relative вместе со свойством z-index; имеет прозрачность, отличную от абсолютной непрозрачности; является элементом flex или grid со свойством z-index; участвует в анимациях, является маской или фильтров; является рутовым элементом. Стекинг контекст компартментализирован: ни один вложенный элемент не может выйти за пределы расположения в стекинг контексте своего родителя, хотя может создать собственный стекинг контекст внутри относительно других детей того же родителя.
+ **Что такое блоковая (или боксовая, блочная) модель (box model)?**
  Каждый элемент на странице помещен в свой собственный прямоугольник, у которого есть параметры высоты и ширины контента, внутренних отступов (padding), внешних оступов (margin) и границы. По умолчанию, при размещении элемента на странице, браузер игнорирует значения границ элемента в его блочной модели. Свойство box-sizing со значением border-box может заставить браузера учитывать эти значения.
+ **Что такое at-rules (@-rules, @-правила, "эт-правила") в CSS? Для чего они нужны, и можете ли привести примеры?**
  Эт-правила задают поведение CSS. Включают в себя @import (подключение внешних стилей), @media (if-правило, которое будет менять содержимое, если выполняется условие), @supports (if-правило, если браузер понимает условие), @keyframes (описание шагов анимаций), @font-face (описывает шрифты), @layer (группирует правила по спецификации), @scope (создает область видимости для правил) и другие.
+ **Что такое вообще каскады? CSS: "Каскадные таблицы стилей". Для чего они нужны?**
  Каскады -- это алгоритм, который говорит браузеру, как комбинировать значения свойств, поступающих из разных источников, а также как решать связанные с ними конфликты. Задача каскадов -- получить "подсчитанные значения", computed value, которые будут присвоены тому или иному свойству элемента страницы. На результат влияют источник (правила) и специфичность селектора.
+ **Что такое специфичность (specificity) в CSS? Что влияет на специфичность в CSS?**
  Специфичность -- алгоритм по определению веса селектора, который требуется для разрешения CSS конфликтов. Учитываются качества селекторов -- идентификаторы, классы и типы (тэги), -- их расположение -- внутри тэга или внутри файла, -- очередность и близость (в случае @scope).
+ **Оптимизация CSS. Что можете рассказать?**
contain: strict, will-change.

## JavaScript и TypeScript
15-25 минут

### Простые

+ **Типы данных в JS. Назовите, какие помните.**
  Примитивные (хранят только одно значение): boolean, string, number, BigInt, symbol, undefined, null. Непримитивные (могут хранить несколько значений): object.
+ + (Если назвали Symbol) **Что такое symbol? Приходилось ли использовать?**
  Иммутабельное и уникальнное значение. Создается фабриков Symbol(). Используется, в том числе, для кастомных итераторов и для задания уникальных ключей в объектах, а также под капотом в React для того, чтобы различать компоненты (и их уникальный стейт).
+ + (Если назвали null и undefined) **Для чего нужны null и undefined? В чем их различия в JavaScript? В чем они похожи?**
  Undefined -- отсуствие значения. Null -- отсутствие объекта. "null" находится в конце цепочки наследования в JS. undefined возвращается при обращении к неинициализированным переменным, из функции с пустым return и не только. Для всех типов данных в JS, кроме null и undefined, есть свои объекты, доступные из их переменных, в которрых содержатся методы для работы с ними. И null, и undefined могут быть подхвачены ??-оператором. Переменные и null, и undefined типа могут принимать только одно значение (null и undefined).
+ + (Если назвали все) **TypeScript как-то расширил этот набор?**
  В TypeScript существуют следующие неуказанные типы данных: Array, Tuple, и Enum (он также понимает Function, Interface и Class). Помимо этого, он позволяет работать с объединением и пересечением типов, literal-типы и не только.
+ **Что такое "хойстинг" (hoisting) в JS?**
  "Всплытие": при первом парсинге кода агенты "перенесут" объявления (и, возможно, дефиниции) переменных в начало кода, так что при первом обращении к этим переменным они уже будут существовать в своих областях видимости. В случае заявленного "use strict;" у этих переменных может еще не быть значения (Temporal Dead Zone -- ошибка при доступе до объявления).
+ **Что такое "замыкание" (closure) в JS? Приходилось ли использовать на практике?**
  Closed-over Variable Enviroment, или, иногда, "backpack": способность языка, при котором коллбек-функции могут "запоминать" свое лексическое окружение (существует в коде), которое существовало на момент своего создания, а также сами функции, которые "запомнили" свое окружение. Замыкания используются в языке повсеместно, и это одна из фундаментальных особенностей JavaScript: promise, конструкторские функции, приватные методы, циклы, компоненты React используют эти возможности.
+ + **Примеры использования?**
  Мемоизация: для сложных вычислений можно сохранять результаты прошлых операций и проверять их наличие при следующих вызовах. Инкапсуляция: "приватные" переменные (к ним нельзя будет обратиться напрямую). Once: функция, которая может быть запущена только один (N) раз или которая может запоминать, сколько раз она была вызвана, и делать что-то иначе в зависимости от этого числа. 
+ + **Как это реализовано? Мы можем обратиться к этому самому запомненному окружению, прочитать значение из него?**
  Копия лексического окружения (объект Closure) помещается в скрытое свойство [[Scopes]]. При обходе цепи видимостей, если переменная не была обнаружена сразу в контексте функции, функция "проверит" наличие этой переменной в этом свойстве, прежде чем отправится выше по цепи. У разработчика нет возможности сослаться на эти переменные из [[Scopes]].Closure напрямую.
+ **Что такое Event Loop?**
  JS -- однопоточный язык, но Event Loop -- это один из механизмов движка / Web API, который позволяет JS коду работать асинхронно. После обработки синхронного top-level кода, Event Loop будет пытаться заполнять стек вызовов задачами из Callback Queue и Microtask Queue, отдавая предпочтение последним. 
+ **Какие есть способы объявления функций в JavaScript? Чем они отличаются друг от друга?**
  Function Declaration: объявляется с помощью ключевого слова function, потом имя функции, потом список параметров и блок кода. Могут быть "подняты" (hoisting) при парсинге. Function Expression: объявляется как значение переменной -- анонимная функция, которой может быть присвоено имя. Допускают рекурсию, если имеют имя. Arrow Functions: краткая запись с ключевым словом =>, в общем случае не требуют "return", "function" или фигурных скобок. Нет своего this и arguments, не могут быть использованы как конструкторы (с new).
+ + (Если упомянули this) **А что такое this? Что можете про него (ключевое слово) рассказать?**
  Ключевое слово, указывающее на контекст выполнения функции. Его значение определяется динамически -- тем, как не-стрелочная функция была вызвана (а не где объявлена). В дот-нотации (используется точка) содержит ссылку на объект до точки. В new содержит ссылку на новый возвращаемый объект. В глобальном контексте содержит ссылку на глоабльный объект (window) или undefined. Методы call, apply, bind позволяют задавать this для функции.
+ **Что такое Promise? Для чего он нужен?**
  Созданный в JS объект, представляющий собой асинхронную операцию (часть Web API), к которому у разработчика есть доступ. Может завершиться успешно (с результатом) или с ошибкой и используется для работы с асинхронным кодом, избегая "ада колбэков" (callback hell). Состояния: pending (начальное), fulfilled (операция успешно завершена) и rejected (операция завершилась ошибкой). Создается через new, а также некоторыми Web API функциями, вроде fetch. Основные методы: then(), catch(), finally(). Основные статические методы: race(), all(), allSettled(). async/await -- с. сахар над промисами.
+ **Для чего нужен TypeScript?**
  Отлов ошибок на этапе компиляции, IntelliSence -- Автодополнение в IDE, безопасный рефакторинг и документирование кода с помощью типов.
+ **Разница между Interface и Type. Когда что использовать?**
  Interface: для объектов / классов, когда требуется расширение / дополнение, для использования через implements в классах. Type: для сложных типов (union, intersection, tuples), более короткого синтаксиса и если нужны utility типы, может использоваться с примитивами (string, number, ...).
+ **Дженерики в TypeScript. Что это такое?**
  "Переменные" для типов: инструмент для создания переиспользуемых обобщенных типов, для работы с разными типами данных, но при сохранении безопасности кода. 
+ **Что такое прототипное наследование? Как оно реализовано в JavaScript?**
  Механизм для получения доступа к свойствам и методам других объектов, выше в цепи протитипов по отношению к самому объекту. Почти у каждого объекта есть условно скрытое свойство __proto__, в котором есть ссылка на его прототип -- родительский объект. При обращении к свойству объекта JS сначала ищет его в самом объекте, а если не находит — проверяет __proto__, затем __proto__.__proto__ и так далее до null.
+ + **Можно ли создать объект без прототипа?**
  Object.create(null)
+ **Классы в JavaScript. Что можете про них рассказать?**
  С. сахар над прототипным наследованием, добавленный в ES6. Упрощают создание объектов с общими методами и наследование, но работают на прототипах. По сути, представляют собой конструкторскую функцию, которая вызывается только через new, и методы / свойства, добавленные в объект, который содержится в .prototype-свойстве этой функции.
+ **Что такое чистые (pure) функции? Для чего они нужны и приходилось ли пользоваться?**
  Всегда возвращает одинаковый результат для одинаковых аргументов (не зависит от внешнего состояния). Не имеет сайд-эффектов (не изменяет внешние переменные, DOM, не делает AJAX-запросов, ...). Используются в React в качестве хуков и компонентов.
+ **Что такое колбеки (callback functions)? Где используются?**
  Функции, которые передаются в другие как аргумент и вызываются внутри, а также возвращаемые функции. Нужны для работы с асинхронным кодом (обработки событий, ожидание ответа от сервера) и гибкости (например, обработки элементов массива).

### Интересные
+ **Что такое контекст выполнения (execution context) функций? Когда он создается и из чего состоит?**
Внутренняя среда, в которой выполняется JS-код. Содержит всю информацию, необходимую для выполнения функции или глобального кода: переменные, аргументы, scope (область видимости) и ссылку на this. Глобальный создается при запуске скрипта, функции -- при вызове. В обоих случаях контекст помещается в Call Stack. Каждый EC содержит свое лексическое окружение (Variable Environment) с объявленными внутри переменные, функциями и аргументами, а также ссылку на внешнее лексическое окружение; this, значение которое определяется динамически в момент вызова; Scope Chain (цепочку областей видимости), нужную для поиска переменных в родительских scope. Удаляется из памяти каждый раз, как функция прекратила работу.
+ **Ключевое слово new. Как работает и где используется?**
Используется для создания экземпляра объекта из функции-конструктора или класса. Алгоритм: 1. создается новый пустой объект, который наследует от .prototype конструкторской функции (obj.__proto__ <- Func.prototype); 2. вызывается сама функция с контекстом (this), который привязывается к новому объекту; 3. возвращается новый объект (если нет return).
+ + (Если упомянуты классы / конструкторские функции) **Что будет, если вызвать их без new?**
Код функции просто отработает, как если бы это была обычная функция (то есть, ошибочно). В глобальном контексте this будет смотреть на глобальный объект, и глобальный объект получит новые свойства.
+ **Вы слышали про race condition?**
Результат кода зависит от порядка выполнения асинхронных операций. Если не предусмотреть, может приводить к ошибкам. Способы избежать: грамотное использование async/await с последовательными запросами или отмена предыдущих запросов (AbortController).
+ **Как можно копировать объекты в JavaScript?**
Глубокое клонирование: JSON.parse(JSON.stringify(obj)), structuredClone(), рекурсивый обход, библиотеки. Иначе скопируется ссылка на объект.
+ + **Что насчет Object.assign и {...obj} (spread operator)? Можно ли с их помощью создать глубокую копию? И есть ли между ними разница?**
Нельзя. .assign() изменяет объект, spread operator создает новый.
+ **Декораторы в TypeScript. Какие бывают и для чего применяются?**
Специальные функции, которые модифицируют классы, методы, свойства или параметры на этапе инициализации (а не во время выполнения). Бывают для классов, методов, свойств и параметров. Активно используются во фреймворках (Dependancy Injection, роутинг; но не в React), отдельно можно отметить валидацию и логирование в качестве примеров.

## React
5-10 минут

+ **Виртуальный DOM (virtual DOM). Объясните это понятие, и для чего он может использоваться?**
  Легковесная копия DOM, которая позволяет не работать с реальным DOM напрямую: изменения вносятся в копию, батчатся, и применяются с помощью React. В этом процессе происходит сравнение DOM-дерева с евиртуальной копией, определяется разница и запускается ререндеринг только тех участков, которые были изменены.
+ + **Как именно React определяет, какие именно участки страницы (компоненты) требуют изменения? Знаете, как называется этот процесс?**
  Процесс: Virtual DOM Diffing. Алгоритм: Reconciliation. Правила: 1. правило ключей: Элементы с разными key считаются разными; правило одинакового типа: если тип элемента изменился (например, div стал span), старое дерево уничтожается, будет пересоздано. Рекурсивное сравнение: для одинаковых типов React рекурсивно проверяет атрибуты и дочерние элементы.
+ **Почему компонент ререндерится?**
  Изменение состояния: если состояние компонента изменяется, React автоматически перерисовывает компонент. Изменение пропсов (по сути, то же): если пропсы компонента изменяются, React перерисовывает компонент. Изменение состояния родителя: если состояние родительского компонента изменяется, React может перерисовать все дочерние компоненты, даже если они не напрямую используют обновленное состояние. 
+ + **Компонент ререндерится при каждом изменении стейта, даже если изменения не влияют на его вывод. Можно ли это как-то исправить? Как вообще устранить лишние ререндеры?**
  useMemo для оптимизации функций, вызываемых внутри рендеринга компонента. useCallback: запомнить callback-функцию и предотвратить пересоздание функции при каждом рендере. Это особенно полезно, когда передаете функцию как пропс дочернему компоненту. Избегать глубоких обновлений состояния: Вместо того чтобы обновлять только часть состояния, обновите весь объект состояния, чтобы избежать лишних рендеров. Оптимизация пропсов: React.memo для оптимизации компонентов, которые не должны перерисовываться при изменении пропсов, если те не должны влиять на внешний вид. useRef: хранить изменяемое значение между рендерами без запуска обновлений. Условный рендеринг. Вынести логику из компонентов.
+ **Расскажите про хуки в React. Какими приходится пользоваться и для чего нужны? Какие есть ограничения на использование?**
  Специальная функция, которая позволяет "подцепиться" к возможностям библиотеки. Например, useState предоставляет функциональным компонентам доступ к состоянию React, useEffect для сайд-эффектов, useContext для доступ к контексту. Можно использовать только в функциональных компонентах или в кастомных хуках. Не должны вызываться в циклах или операторах ветвления, должны вызываться только на верхнем уровне
+ + **Как работает UseEffect? Чем отличается от useLayoutEffect?**
  useEffect: выполняется после рендера и раскраски (layout и paint). Используется для сайд-эффектов (запросы к API, подписки). useLayoutEffect: выполняется до раскраски. Используется, если нужно измерить DOM или синхронно изменить его перед отрисовкой.
+ + **Преимущества useReducer перед useState?**
  useReducer полезен для сложного состояния, когда есть много действий (actions), изменяющих состояние, или состояние зависит от предыдущего (например, формы, стейт-машины).
+ **Объясните жизненный цикл компонентов. Какие методы жизненного цикла вы знаете?**
  Набор стадий, через которые проходит компонент от момента его создания до удаления из DOM. Разделен на три основные фазы: монтирование (mounting), обновление (updating) и размонтирование (unmounting). Эти фазы отражены в соответствующих методах жизненного цикла, которые позволяют выполнять действия в определенные моменты жизни компонента: при инициализации, получении новых пропсов, удалении из DOM. 
+ **Приходилось ли пользоваться Redux? Чем практически отличается от useContext?**
  Context API подходит для простых сценариев (темы, локальный стейт). Ререндер всех потребителей при изменении контекста. Redux для сложных приложений с глобальным состоянием. Плюсы: есть middleware (thunk, saga), свои DevTools и предсказуемость. Если нет частых обновлений стейта и не нужны плагины, выбрать Context API.
+ + **Как оптимизировоать Context?**
  Разделить контексты (ThemeContext, UserContext) и мемоизировать значение контекста.
